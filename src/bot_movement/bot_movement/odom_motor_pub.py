#!/usr/bin/env python3

"""
C-Robot Odometer Node (ROS 2)

This script provides ROS 2 integration for reading encoder data from two motors and
publishing their RPM values and pulse counts using RPi.GPIO.

Date: [Converted to ROS 2]

ROS 2 Node Name: crobot_odom

Published Topics:
  - /right_motor_rpm (std_msgs/Float64) - RPM value of the right motor
  - /left_motor_rpm (std_msgs/Float64) - RPM value of the left motor
  - /right_motor_pulses (std_msgs/Int32) - Pulse count of the right motor
  - /left_motor_pulses (std_msgs/Int32) - Pulse count of the left motor

Parameters:
  - left_encoder_pin (int): GPIO pin number for the left motor encoder.
  - right_encoder_pin (int): GPIO pin number for the right motor encoder.
  - gear_ratio (float): Gear ratio of the motor system.
  - pulses_per_revolution (int): Number of pulses generated by the encoder for one revolution.
  - publishing_rate (float): Publishing rate per second for RPM values and pulse counts.

Note: Ensure RPi.GPIO is installed before running this script.
"""

import rclpy
from rclpy.node import Node
from std_msgs.msg import Float64, Int32
import RPi.GPIO as GPIO
import time

GPIO.setwarnings(False)

class MotorOdometer(Node):
    def __init__(self, left_encoder_pin, right_encoder_pin, gear_ratio, pulses_per_revolution, publishing_rate):
        super().__init__('crobot_odom')

        self.left_encoder_pin = left_encoder_pin
        self.right_encoder_pin = right_encoder_pin
        self.gear_ratio = gear_ratio
        self.pulses_per_revolution = pulses_per_revolution
        self.publishing_interval = 1.0 / publishing_rate
        self.pulse_count_left_motor = 0
        self.pulse_count_right_motor = 0

        # GPIO Setup
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.left_encoder_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)
        GPIO.setup(self.right_encoder_pin, GPIO.IN, pull_up_down=GPIO.PUD_UP)

        GPIO.add_event_detect(self.left_encoder_pin, GPIO.FALLING, callback=self.encoder_callback_left)
        GPIO.add_event_detect(self.right_encoder_pin, GPIO.FALLING, callback=self.encoder_callback_right)

        # ROS 2 Publishers
        self.pub_right_rpm = self.create_publisher(Float64, 'right_motor_rpm', 10)
        self.pub_left_rpm = self.create_publisher(Float64, 'left_motor_rpm', 10)
        self.pub_pulse_data_right = self.create_publisher(Int32, 'right_motor_pulses', 10)
        self.pub_pulse_data_left = self.create_publisher(Int32, 'left_motor_pulses', 10)

        # Timer for publishing data
        self.timer = self.create_timer(self.publishing_interval, self.publish_data)

    def encoder_callback_right(self, channel):
        """
        Callback function for the right motor encoder.
        Increments the pulse count for the right motor.
        """
        self.pulse_count_right_motor += 1

    def encoder_callback_left(self, channel):
        """
        Callback function for the left motor encoder.
        Increments the pulse count for the left motor.
        """
        self.pulse_count_left_motor += 1

    def calculate_rpm(self, pulse_count):
        """
        Calculate the RPM value based on the pulse count.
        """
        rpm = ((pulse_count / self.pulses_per_revolution) / self.publishing_interval * 60) / self.gear_ratio
        return self.reduce_noise(rpm)

    def reduce_noise(self, rpm):
        """
        Apply noise reduction to the RPM value.
        """
        return rpm  # Placeholder for noise reduction logic

    def publish_data(self):
        """
        Publish the RPM values and pulse counts to ROS topics.
        """
        rpm_right = self.calculate_rpm(self.pulse_count_right_motor)
        rpm_left = self.calculate_rpm(self.pulse_count_left_motor)

        self.pub_right_rpm.publish(Float64(data=rpm_right))
        self.pub_left_rpm.publish(Float64(data=rpm_left))
        self.pub_pulse_data_right.publish(Int32(data=self.pulse_count_right_motor))
        self.pub_pulse_data_left.publish(Int32(data=self.pulse_count_left_motor))

        # Reset pulse counts for the next cycle
        self.pulse_count_right_motor = 0
        self.pulse_count_left_motor = 0

def main(args=None):
    rclpy.init(args=args)

    # Define GPIO pin numbers, gear ratio, pulses per revolution, and publishing rate
    LEFT_MOTOR_ENCODER_PIN = 23
    RIGHT_MOTOR_ENCODER_PIN = 24
    GEAR_RATIO = 30.0
    PULSE_PER_REVOLUTION = 30.0
    PUBLISHING_RATE = 10  # Publish 10 data points per second

    motor_odometer = MotorOdometer(LEFT_MOTOR_ENCODER_PIN, RIGHT_MOTOR_ENCODER_PIN, GEAR_RATIO, PULSE_PER_REVOLUTION, PUBLISHING_RATE)

    try:
        rclpy.spin(motor_odometer)
    except KeyboardInterrupt:
        motor_odometer.get_logger().info("Shutting down...")
        GPIO.cleanup()
    finally:
        motor_odometer.destroy_node()
        rclpy.shutdown()
        GPIO.cleanup()

if __name__ == "__main__":
    main()
